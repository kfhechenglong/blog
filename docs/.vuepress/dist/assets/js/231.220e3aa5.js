(window.webpackJsonp=window.webpackJsonp||[]).push([[231],{651:function(v,_,e){"use strict";e.r(_);var c=e(54),o=Object(c.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h2",{attrs:{id:"vue2及vue3响应式原理理解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue2及vue3响应式原理理解"}},[v._v("#")]),v._v(" "),e("code",[v._v("vue2")]),v._v("及"),e("code",[v._v("vue3")]),v._v("响应式原理理解")]),v._v(" "),e("p",[v._v("响应式数据的核心就是数据变化能被知道，对象在"),e("code",[v._v("vue2")]),v._v("中使用了"),e("code",[v._v("defineProperty")]),v._v("将数据定义成响应式数据（拦截了所有的）")]),v._v(" "),e("ol",[e("li",[v._v("所谓数据响应式就是能够使数据变化可以被检测并对这种变化做出响应的机制。")]),v._v(" "),e("li",[e("code",[v._v("MVVM")]),v._v("框架中要解决的一个核心问题是连接数据层和视图层，通过数据驱动应用，数据变化，视图更新，要做\n到这点的就需要对数据做响应式处理，这样一旦数据发生变化就可以立即做出更新处理。")]),v._v(" "),e("li",[v._v("以"),e("code",[v._v("vue")]),v._v("为例说明，通过数据响应式加上虚拟"),e("code",[v._v("DOM")]),v._v("和"),e("code",[v._v("patch")]),v._v("算法，开发人员只需要操作数据，关心业务，完全不\n用接触繁琐的"),e("code",[v._v("DOM")]),v._v("操作，从而大大提升开发效率，降低开发难度。")]),v._v(" "),e("li",[e("code",[v._v("vue2")]),v._v("中的数据响应式会根据数据类型来做不同处理，如果是对象则采用"),e("code",[v._v("ObjectdefineProperty()")]),v._v("的方式定义数据拦截，当数据被访问或发生变化时，我们感知并作出响应;如果是数组则通过覆盖数组对象原型的7个变更方法，使这些方法可以额外的做更新通知，从而作出响应。这种机制很好的解决了数据响应化的问题，但在实际使用中也存在一些缺点:比如初始化时的递归遍历会造成性能损失;新增或删除属性时需要用户使用 "),e("code",[v._v("Vue set/delete")]),v._v("这样特殊的"),e("code",[v._v("api")]),v._v("才能生效;对于"),e("code",[v._v("es6")]),v._v("中新产生的"),e("code",[v._v("Map/Set")]),v._v("这些数据结构不支持等问题。")]),v._v(" "),e("li",[v._v("为了解决这些问题，"),e("code",[v._v("vue3")]),v._v("重新编写了这一部分的实现:利用"),e("code",[v._v("ES6")]),v._v("的"),e("code",[v._v("Proxy")]),v._v("代理要响应化的数据，它有很多好\n处，编程体验是一致的，不需要使用特殊"),e("code",[v._v("api")]),v._v("，初始化性能和内存消耗都得到了大幅改善;另外由于响应化的\n实现代码抽取为独立的"),e("code",[v._v("reactivity")]),v._v("包，使得我们可以更灵活的使用它，第三方的扩展开发起来更加灵活了。")])]),v._v(" "),e("h2",{attrs:{id:"vue中的diff算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue中的diff算法"}},[v._v("#")]),v._v(" "),e("code",[v._v("vue")]),v._v("中的"),e("code",[v._v("diff")]),v._v("算法")]),v._v(" "),e("ol",[e("li",[e("code",[v._v("vue2")]),v._v("中的"),e("code",[v._v("diff")]),v._v("算法称为"),e("code",[v._v("patching")]),v._v("算法，它由"),e("code",[v._v("Snabbdom")]),v._v("修改而来，虚拟"),e("code",[v._v("DOM")]),v._v("要想转化为真实"),e("code",[v._v("DOM")]),v._v("就需要通过\n"),e("code",[v._v("patch")]),v._v("方法转换。")]),v._v(" "),e("li",[v._v("最初"),e("code",[v._v("Vue1.x")]),v._v("视图中每个依赖均有更新函数对应，可以做到精准更新，因此并不需要虚拟"),e("code",[v._v("DOM")]),v._v("和"),e("code",[v._v("patching")]),v._v("算法支持.但是这样粒度过细导致"),e("code",[v._v("Vue1x")]),v._v("无法承载较大应用;"),e("code",[v._v("Vue2x")]),v._v("中为了降低"),e("code",[v._v("Watcher")]),v._v("粒度.每个组件只有一个 "),e("code",[v._v("Watcher")]),v._v("与之对应，此时就需要引入"),e("code",[v._v("patching")]),v._v("算法才能精确找到发生变化的地方并高效更新。")]),v._v(" "),e("li",[e("code",[v._v("vue")]),v._v("中"),e("code",[v._v("diff执")]),v._v("行的时刻是组件内响应式数据变更触发实例执行其更新函数时，更新函数会再次执行"),e("code",[v._v("render")]),v._v("函数获得最新的虚拟"),e("code",[v._v("DOM")]),v._v(".然后执行"),e("code",[v._v("patch")]),v._v("函数。并传入新旧两次虚拟"),e("code",[v._v("DOM")]),v._v("，通过比对两者找到变化的地方。最后将其转化为对应的"),e("code",[v._v("DOM")]),v._v("操作。")]),v._v(" "),e("li",[e("code",[v._v("patch")]),v._v("过程是一个递归过程，遵循深度优先、同层比较的策略;")])]),v._v(" "),e("p",[v._v("以"),e("code",[v._v("vue3")]),v._v("的"),e("code",[v._v("patch")]),v._v("为例:\n首先判断两个节点是否为相同同类节点，不同则删除重新创建如果双方都是文本则更新文本内容")]),v._v(" "),e("p",[v._v("如果双方都是元素节点则递归更新子元素，同时更新元素属性更新子节点时又分了几种情况:")]),v._v(" "),e("ul",[e("li",[v._v("新的子节点是文本，老的子节点是数组则清空，并设置文本;")]),v._v(" "),e("li",[v._v("新的子节点是文本，老的子节点是文本则直接更新文本;")]),v._v(" "),e("li",[v._v("新的子节点是数组，老的子节点是文本则清空文本，并创建新子节点数组中的子元素;")]),v._v(" "),e("li",[v._v("新的子节点是数组，老的子节点也是数组。那么比较两组子节点，更新细节")])]),v._v(" "),e("ol",{attrs:{start:"5"}},[e("li",[e("code",[v._v("vue3")]),v._v("中引入的更新策略:编译期优化"),e("code",[v._v("patchFlags")]),v._v("、"),e("code",[v._v("block")]),v._v("等")])])])}),[],!1,null,null,null);_.default=o.exports}}]);